From 3e1f70fe02b29daa79860248b029e19c46a45e2f Mon Sep 17 00:00:00 2001
From: Victor Zverovich <victor.zverovich@gmail.com>
Date: Wed, 20 Nov 2019 12:20:17 -0800
Subject: [PATCH 155/186] Merge write_fp into write

---
 include/fmt/format-inl.h |   2 +-
 include/fmt/format.h     | 169 ++++++++++++++++-----------------------
 include/fmt/printf.h     |   2 +-
 test/locale-test.cc      |   7 --
 4 files changed, 73 insertions(+), 107 deletions(-)

diff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h
index 53559ee1..e662d0e3 100644
--- a/include/fmt/format-inl.h
+++ b/include/fmt/format-inl.h
@@ -1,4 +1,4 @@
-// Formatting library for C++
+// Formatting library for C++ - implementation
 //
 // Copyright (c) 2012 - 2016, Victor Zverovich
 // All rights reserved.
diff --git a/include/fmt/format.h b/include/fmt/format.h
index 152deee6..3d90387e 100644
--- a/include/fmt/format.h
+++ b/include/fmt/format.h
@@ -1690,7 +1690,6 @@ template <typename Range> class basic_writer {
   };
 
  public:
-  /** Constructs a ``basic_writer`` object. */
   explicit basic_writer(Range out,
                         internal::locale_ref loc = internal::locale_ref())
       : out_(out.begin()), locale_(loc) {}
@@ -1743,29 +1742,79 @@ template <typename Range> class basic_writer {
                                    int_writer<T, Spec>(*this, value, spec));
   }
 
-  void write(float value, const format_specs& specs = format_specs()) {
-    write_fp(value, specs);
-  }
+  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
+  void write(T value, const format_specs& specs = {}) {
+    auto sign = specs.sign;
+    if (std::signbit(value)) {  // value < 0 is false for NaN so use signbit.
+      sign = sign::minus;
+      value = -value;
+    } else if (sign == sign::minus) {
+      sign = sign::none;
+    }
 
-  void write(double value, const format_specs& specs = format_specs()) {
-    write_fp(value, specs);
-  }
+    float_spec fspec = parse_float_type_spec(specs.type);
+    if (!std::isfinite(value)) {
+      const char* str = std::isinf(value) ? (fspec.upper ? "INF" : "inf")
+                                          : (fspec.upper ? "NAN" : "nan");
+      return write_padded(specs, inf_or_nan_writer{sign, fspec.percent, str});
+    }
 
-  /**
-    \rst
-    Formats *value* using the general format for floating-point numbers
-    (``'g'``) and writes it to the buffer.
-    \endrst
-   */
-  void write(long double value, const format_specs& specs = format_specs()) {
-    write_fp(value, specs);
+    if (fspec.percent) value *= 100;
+
+    memory_buffer buffer;
+    int exp = 0;
+    int precision = specs.precision >= 0 || !specs.type ? specs.precision : 6;
+    int num_digits =
+        fspec.format == float_format::exp ? precision + 1 : precision;
+    unsigned options = 0;
+    if (fspec.format == float_format::fixed) options |= grisu_options::fixed;
+    if (const_check(sizeof(value) == sizeof(float)))
+      options |= grisu_options::binary32;
+    bool use_grisu = internal::use_grisu<T>() &&
+                     (specs.type != 'a' && specs.type != 'A') &&
+                     grisu_format(static_cast<double>(value), buffer,
+                                  num_digits, options, exp);
+    char* decimal_point_pos = nullptr;
+    if (!use_grisu) decimal_point_pos = sprintf_format(value, buffer, specs);
+
+    if (fspec.percent) {
+      buffer.push_back('%');
+      --exp;  // Adjust decimal place position.
+    }
+    format_specs as = specs;
+    if (specs.align == align::numeric) {
+      if (sign) {
+        auto&& it = reserve(1);
+        *it++ = static_cast<char_type>(data::signs[sign]);
+        sign = sign::none;
+        if (as.width) --as.width;
+      }
+      as.align = align::right;
+    } else if (specs.align == align::none) {
+      as.align = align::right;
+    }
+    char_type point = fspec.locale ? decimal_point<char_type>(locale_)
+                                   : static_cast<char_type>('.');
+    if (use_grisu) {
+      auto params = gen_digits_params();
+      params.sign = sign;
+      params.format = fspec.format;
+      params.num_digits = num_digits;
+      params.trailing_zeros =
+          (precision != 0 &&
+           (!specs.type || fspec.format == float_format::fixed ||
+            fspec.format == float_format::exp)) ||
+          specs.alt;
+      params.upper = fspec.upper;
+      num_digits = static_cast<int>(buffer.size());
+      write_padded(as, grisu_writer<char_type>(buffer.data(), num_digits, exp,
+                                               params, point));
+    } else {
+      write_padded(as, double_writer{sign, buffer, decimal_point_pos, point});
+    }
   }
 
-  // Formats a floating-point number (float, double, or long double).
-  template <typename T, bool USE_GRISU = internal::use_grisu<T>()>
-  void write_fp(T value, const format_specs& specs);
-
-  /** Writes a character to the buffer. */
+  // Writes a character to the buffer.
   void write(char value) {
     auto&& it = reserve(1);
     *it++ = value;
@@ -1777,11 +1826,7 @@ template <typename Range> class basic_writer {
     *it++ = value;
   }
 
-  /**
-    \rst
-    Writes *value* to the buffer.
-    \endrst
-   */
+  // Writes value to the buffer.
   void write(string_view value) {
     auto&& it = reserve(value.size());
     it = internal::copy_str<char_type>(value.begin(), value.end(), it);
@@ -1820,78 +1865,6 @@ template <typename Range> class basic_writer {
   }
 };
 
-template <typename Range>
-template <typename T, bool USE_GRISU>
-void basic_writer<Range>::write_fp(T value, const format_specs& specs) {
-  auto sign = specs.sign;
-  if (std::signbit(value)) {  // value < 0 is false for NaN so use signbit.
-    sign = sign::minus;
-    value = -value;
-  } else if (sign == sign::minus) {
-    sign = sign::none;
-  }
-
-  float_spec fspec = parse_float_type_spec(specs.type);
-  if (!std::isfinite(value)) {
-    const char* str = std::isinf(value) ? (fspec.upper ? "INF" : "inf")
-                                        : (fspec.upper ? "NAN" : "nan");
-    return write_padded(specs, inf_or_nan_writer{sign, fspec.percent, str});
-  }
-
-  if (fspec.percent) value *= 100;
-
-  memory_buffer buffer;
-  int exp = 0;
-  int precision = specs.precision >= 0 || !specs.type ? specs.precision : 6;
-  int num_digits =
-      fspec.format == float_format::exp ? precision + 1 : precision;
-  unsigned options = 0;
-  if (fspec.format == float_format::fixed) options |= grisu_options::fixed;
-  if (const_check(sizeof(value) == sizeof(float)))
-    options |= grisu_options::binary32;
-  bool use_grisu = USE_GRISU && (specs.type != 'a' && specs.type != 'A') &&
-                   grisu_format(static_cast<double>(value), buffer, num_digits,
-                                options, exp);
-  char* decimal_point_pos = nullptr;
-  if (!use_grisu) decimal_point_pos = sprintf_format(value, buffer, specs);
-
-  if (fspec.percent) {
-    buffer.push_back('%');
-    --exp;  // Adjust decimal place position.
-  }
-  format_specs as = specs;
-  if (specs.align == align::numeric) {
-    if (sign) {
-      auto&& it = reserve(1);
-      *it++ = static_cast<char_type>(data::signs[sign]);
-      sign = sign::none;
-      if (as.width) --as.width;
-    }
-    as.align = align::right;
-  } else if (specs.align == align::none) {
-    as.align = align::right;
-  }
-  char_type point = fspec.locale ? decimal_point<char_type>(locale_)
-                                 : static_cast<char_type>('.');
-  if (use_grisu) {
-    auto params = gen_digits_params();
-    params.sign = sign;
-    params.format = fspec.format;
-    params.num_digits = num_digits;
-    params.trailing_zeros =
-        (precision != 0 &&
-         (!specs.type || fspec.format == float_format::fixed ||
-          fspec.format == float_format::exp)) ||
-        specs.alt;
-    params.upper = fspec.upper;
-    num_digits = static_cast<int>(buffer.size());
-    write_padded(as, grisu_writer<char_type>(buffer.data(), num_digits, exp,
-                                             params, point));
-  } else {
-    write_padded(as, double_writer{sign, buffer, decimal_point_pos, point});
-  }
-}
-
 using writer = basic_writer<buffer_range<char>>;
 
 template <typename T> struct is_integral : std::is_integral<T> {};
@@ -1983,7 +1956,7 @@ class arg_formatter_base {
 
   template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
   iterator operator()(T value) {
-    writer_.write_fp(value, specs_ ? *specs_ : format_specs());
+    writer_.write(value, specs_ ? *specs_ : format_specs());
     return out();
   }
 
diff --git a/include/fmt/printf.h b/include/fmt/printf.h
index 17a20afb..cdbb65e6 100644
--- a/include/fmt/printf.h
+++ b/include/fmt/printf.h
@@ -1,4 +1,4 @@
-// Formatting library for C++
+// Formatting library for C++ - legacy printf implementation
 //
 // Copyright (c) 2012 - 2016, Victor Zverovich
 // All rights reserved.
diff --git a/test/locale-test.cc b/test/locale-test.cc
index d1922328..a064ecda 100644
--- a/test/locale-test.cc
+++ b/test/locale-test.cc
@@ -42,13 +42,6 @@ template <typename Char> struct small_grouping : std::numpunct<Char> {
 TEST(LocaleTest, DoubleDecimalPoint) {
   std::locale loc(std::locale(), new numpunct<char>());
   EXPECT_EQ("1?23", fmt::format(loc, "{:n}", 1.23));
-  // Test with Grisu disabled.
-  fmt::memory_buffer buf;
-  fmt::internal::writer w(buf, fmt::internal::locale_ref(loc));
-  auto specs = fmt::format_specs();
-  specs.type = 'n';
-  w.write_fp<double, false>(1.23, specs);
-  EXPECT_EQ(fmt::to_string(buf), "1?23");
 }
 
 TEST(LocaleTest, Format) {
-- 
2.21.0 (Apple Git-122.2)

