From 12f9437e224946e163726d9d6ed31f8591c510c2 Mon Sep 17 00:00:00 2001
From: Rosen Penev <rosenp@gmail.com>
Date: Thu, 7 Nov 2019 12:57:30 -0800
Subject: [PATCH 119/186] [clang-tidy] Use auto

Found with hicpp-use-auto

Signed-off-by: Rosen Penev <rosenp@gmail.com>
---
 include/fmt/format-inl.h |  2 +-
 include/fmt/format.h     | 12 ++++++------
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h
index 0904fa40..22b7c82d 100644
--- a/include/fmt/format-inl.h
+++ b/include/fmt/format-inl.h
@@ -800,7 +800,7 @@ FMT_ALWAYS_INLINE digits::result grisu_gen_digits(fp value, uint64_t error,
   // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
   // zero because it contains a product of two 64-bit numbers with MSB set (due
   // to normalization) - 1, shifted right by at most 60 bits.
-  uint32_t integral = static_cast<uint32_t>(value.f >> -one.e);
+  auto integral = static_cast<uint32_t>(value.f >> -one.e);
   FMT_ASSERT(integral != 0, "");
   FMT_ASSERT(integral == value.f >> -one.e, "");
   // The fractional part of scaled value (p2 in Grisu) c = value % one.
diff --git a/include/fmt/format.h b/include/fmt/format.h
index 329e343f..0c14ebda 100644
--- a/include/fmt/format.h
+++ b/include/fmt/format.h
@@ -862,7 +862,7 @@ inline Char* format_decimal(Char* buffer, UInt value, int num_digits,
     // Integer division is slow so do it for a group of two digits instead
     // of for every digit. The idea comes from the talk by Alexandrescu
     // "Three Optimization Tips for C++". See speed-test for a comparison.
-    unsigned index = static_cast<unsigned>((value % 100) * 2);
+    auto index = static_cast<unsigned>((value % 100) * 2);
     value /= 100;
     *--buffer = static_cast<Char>(data::digits[index + 1]);
     add_thousands_sep(buffer);
@@ -873,7 +873,7 @@ inline Char* format_decimal(Char* buffer, UInt value, int num_digits,
     *--buffer = static_cast<Char>('0' + value);
     return end;
   }
-  unsigned index = static_cast<unsigned>(value * 2);
+  auto index = static_cast<unsigned>(value * 2);
   *--buffer = static_cast<Char>(data::digits[index + 1]);
   add_thousands_sep(buffer);
   *--buffer = static_cast<Char>(data::digits[index]);
@@ -1568,7 +1568,7 @@ template <typename Range> class basic_writer {
     void on_num() {
       std::string groups = internal::grouping<char_type>(writer.locale_);
       if (groups.empty()) return on_dec();
-      char_type sep = internal::thousands_sep<char_type>(writer.locale_);
+      auto sep = internal::thousands_sep<char_type>(writer.locale_);
       if (!sep) return on_dec();
       int num_digits = internal::count_digits(abs_value);
       int size = num_digits;
@@ -2965,7 +2965,7 @@ class format_int {
       // Integer division is slow so do it for a group of two digits instead
       // of for every digit. The idea comes from the talk by Alexandrescu
       // "Three Optimization Tips for C++". See speed-test for a comparison.
-      unsigned index = static_cast<unsigned>((value % 100) * 2);
+      auto index = static_cast<unsigned>((value % 100) * 2);
       value /= 100;
       *--ptr = internal::data::digits[index + 1];
       *--ptr = internal::data::digits[index];
@@ -2974,14 +2974,14 @@ class format_int {
       *--ptr = static_cast<char>('0' + value);
       return ptr;
     }
-    unsigned index = static_cast<unsigned>(value * 2);
+    auto index = static_cast<unsigned>(value * 2);
     *--ptr = internal::data::digits[index + 1];
     *--ptr = internal::data::digits[index];
     return ptr;
   }
 
   void format_signed(long long value) {
-    unsigned long long abs_value = static_cast<unsigned long long>(value);
+    auto abs_value = static_cast<unsigned long long>(value);
     bool negative = value < 0;
     if (negative) abs_value = 0 - abs_value;
     str_ = format_decimal(abs_value);
-- 
2.21.0 (Apple Git-122.2)

