From a1fb5c73375a82562f7f2df2081fd0c8101542b7 Mon Sep 17 00:00:00 2001
From: Rosen Penev <rosenp@gmail.com>
Date: Thu, 7 Nov 2019 12:40:46 -0800
Subject: [PATCH 115/186] [clang-tidy] Changes suffixes to uppercase

Found with hicpp-uppercase-literal-suffix

Signed-off-by: Rosen Penev <rosenp@gmail.com>
---
 include/fmt/core.h       |  2 +-
 include/fmt/format-inl.h | 16 ++++++++--------
 include/fmt/format.h     |  2 +-
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/include/fmt/core.h b/include/fmt/core.h
index 1417e941..34aac1c9 100644
--- a/include/fmt/core.h
+++ b/include/fmt/core.h
@@ -919,7 +919,7 @@ using mapped_type_constant =
 enum { packed_arg_bits = 5 };
 // Maximum number of arguments with packed types.
 enum { max_packed_args = 63 / packed_arg_bits };
-enum : unsigned long long { is_unpacked_bit = 1ull << 63 };
+enum : unsigned long long { is_unpacked_bit = 1ULL << 63 };
 
 template <typename Context> class arg_map;
 }  // namespace internal
diff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h
index 766dc007..396617da 100644
--- a/include/fmt/format-inl.h
+++ b/include/fmt/format-inl.h
@@ -286,8 +286,8 @@ const char basic_data<T>::hex_digits[] = "0123456789abcdef";
 
 template <typename T>
 const uint64_t basic_data<T>::powers_of_10_64[] = {
-    1, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ull),
-    10000000000000000000ull};
+    1, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
+    10000000000000000000ULL};
 
 template <typename T>
 const uint32_t basic_data<T>::zero_or_powers_of_10_32[] = {0,
@@ -295,8 +295,8 @@ const uint32_t basic_data<T>::zero_or_powers_of_10_32[] = {0,
 
 template <typename T>
 const uint64_t basic_data<T>::zero_or_powers_of_10_64[] = {
-    0, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ull),
-    10000000000000000000ull};
+    0, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
+    10000000000000000000ULL};
 
 // Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
 // These are generated by support/compute-powers.py.
@@ -373,7 +373,7 @@ class fp {
   static FMT_CONSTEXPR_DECL const int double_significand_size =
       std::numeric_limits<double>::digits - 1;
   static FMT_CONSTEXPR_DECL const uint64_t implicit_bit =
-      1ull << double_significand_size;
+      1ULL << double_significand_size;
 
  public:
   significand_type f;
@@ -412,7 +412,7 @@ class fp {
     const int exponent_size =
         bits<Double>::value - double_significand_size - 1;  // -1 for sign
     const uint64_t significand_mask = implicit_bit - 1;
-    const uint64_t exponent_mask = (~0ull >> 1) & ~significand_mask;
+    const uint64_t exponent_mask = (~0ULL >> 1) & ~significand_mask;
     const int exponent_bias = (1 << exponent_size) - limits::max_exponent - 1;
     auto u = bit_cast<uint64_t>(d);
     f = u & significand_mask;
@@ -796,7 +796,7 @@ enum result {
 template <typename Handler>
 FMT_ALWAYS_INLINE digits::result grisu_gen_digits(fp value, uint64_t error,
                                                   int& exp, Handler& handler) {
-  const fp one(1ull << -value.e, value.e);
+  const fp one(1ULL << -value.e, value.e);
   // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
   // zero because it contains a product of two 64-bit numbers with MSB set (due
   // to normalization) - 1, shifted right by at most 60 bits.
@@ -1022,7 +1022,7 @@ void fallback_format(Double d, buffer<char>& buf, int& exp10) {
     denominator <<= shift - value.e;
     lower.assign(1);
     if (shift != 1) {
-      upper_store.assign(1ull << 1);
+      upper_store.assign(1ULL << 1);
       upper = &upper_store;
     }
   }
diff --git a/include/fmt/format.h b/include/fmt/format.h
index a3d1ee31..5f6519e4 100644
--- a/include/fmt/format.h
+++ b/include/fmt/format.h
@@ -740,7 +740,7 @@ inline int count_digits(uint128_t n) {
     if (n < 100) return count + 1;
     if (n < 1000) return count + 2;
     if (n < 10000) return count + 3;
-    n /= 10000u;
+    n /= 10000U;
     count += 4;
   }
 }
-- 
2.21.0 (Apple Git-122.2)

